// Path: ..\src\cpu\instruction\gen_tests\aslr.rs
// This file is autogenerated from tests\aslr.tests

#![allow(unused_imports)]

use std::cell::RefCell;
use std::rc::Rc;
use crate::register::ProgramCounter;
use crate::mem::rammemory::RamMemory;
use crate::cpu::instruction::GetDisassemblyResult;
use crate::mem::memory::Memory;
use crate::mem::ciamemory::CiaMemory;
use crate::cpu::{Cpu, CpuSpeed};
use crate::mem::Mem;
use crate::modermodem::Modermodem;
use crate::register::STATUS_REGISTER_MASK_CARRY;
use crate::register::STATUS_REGISTER_MASK_EXTEND;
use crate::register::STATUS_REGISTER_MASK_NEGATIVE;
use crate::register::STATUS_REGISTER_MASK_OVERFLOW;
use crate::register::STATUS_REGISTER_MASK_ZERO;


#[test]
fn asl_b_register_by_immediate_cx_set() {
    // arrange - code
    // ASL.B #$06,D0
    let code = [0xED, 0x00].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000005, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$06,D0"),
            vec![0xED00]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000040, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_cx_clear() {
    // arrange - code
    // ASL.B #$06,D0
    let code = [0xED, 0x00].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000001, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$06,D0"),
            vec![0xED00]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000040, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_n_set() {
    // arrange - code
    // ASL.B #$06,D0
    let code = [0xED, 0x00].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000002, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$06,D0"),
            vec![0xED00]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_n_clear() {
    // arrange - code
    // ASL.B #$02,D7
    let code = [0xE5, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000005);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$02,D7"),
            vec![0xE507]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000014);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_z_set() {
    // arrange - code
    // ASL.B #$02,D7
    let code = [0xE5, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000c0);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$02,D7"),
            vec![0xE507]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_z_clear() {
    // arrange - code
    // ASL.B #$02,D7
    let code = [0xE5, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000001);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$02,D7"),
            vec![0xE507]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000004);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_v_set() {
    // arrange - code
    // ASL.B #$03,D7
    let code = [0xE7, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000040);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$03,D7"),
            vec![0xE707]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_immediate_v_clear() {
    // arrange - code
    // ASL.B #$03,D7
    let code = [0xE7, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000008);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("#$03,D7"),
            vec![0xE707]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000040);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_cx_set() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0000000c);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000001);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_cx_clear() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000078);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0000000f);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_n_set() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000c0);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000f8);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_n_clear() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000070);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0000000e);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_z_set() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000007);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_z_clear() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000008);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000001);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_immediate_v_clear() {
    // arrange - code
    // ASR.B #$03,D7
    let code = [0xE6, 0x07].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000018);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("#$03,D7"),
            vec![0xE607]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000003);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_cx_set() {
    // arrange - code
    // ASL.W #$06,D0
    let code = [0xED, 0x40].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000505, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$06,D0"),
            vec![0xED40]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00004140, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_cx_clear() {
    // arrange - code
    // ASL.W #$06,D0
    let code = [0xED, 0x40].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000101, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$06,D0"),
            vec![0xED40]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00004040, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_n_set() {
    // arrange - code
    // ASL.W #$06,D0
    let code = [0xED, 0x40].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000202, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$06,D0"),
            vec![0xED40]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00008080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_n_clear() {
    // arrange - code
    // ASL.W #$02,D7
    let code = [0xE5, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000505);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$02,D7"),
            vec![0xE547]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00001414);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_z_set() {
    // arrange - code
    // ASL.W #$02,D7
    let code = [0xE5, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0000c000);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$02,D7"),
            vec![0xE547]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_z_clear() {
    // arrange - code
    // ASL.W #$02,D7
    let code = [0xE5, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000101);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$02,D7"),
            vec![0xE547]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000404);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_v_set() {
    // arrange - code
    // ASL.W #$03,D7
    let code = [0xE7, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00004000);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$03,D7"),
            vec![0xE747]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_immediate_v_clear() {
    // arrange - code
    // ASL.W #$03,D7
    let code = [0xE7, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000808);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("#$03,D7"),
            vec![0xE747]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00004040);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_cx_set() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000c0c);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000181);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_cx_clear() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00007878);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000f0f);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_n_set() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0000c0c0);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0000f818);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_n_clear() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00007070);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000e0e);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_z_set() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000007);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_z_clear() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000808);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000101);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_immediate_v_clear() {
    // arrange - code
    // ASR.W #$03,D7
    let code = [0xE6, 0x47].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00001818);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("#$03,D7"),
            vec![0xE647]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000303);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_cx_set() {
    // arrange - code
    // ASL.L #$06,D0
    let code = [0xED, 0x80].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x05050505, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$06,D0"),
            vec![0xED80]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x41414140, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_cx_clear() {
    // arrange - code
    // ASL.L #$06,D0
    let code = [0xED, 0x80].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x01010101, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$06,D0"),
            vec![0xED80]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x40404040, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_n_set() {
    // arrange - code
    // ASL.L #$06,D0
    let code = [0xED, 0x80].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x02020202, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$06,D0"),
            vec![0xED80]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x80808080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_n_clear() {
    // arrange - code
    // ASL.L #$02,D7
    let code = [0xE5, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x05050505);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$02,D7"),
            vec![0xE587]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x14141414);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_z_set() {
    // arrange - code
    // ASL.L #$02,D7
    let code = [0xE5, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0xc0000000);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$02,D7"),
            vec![0xE587]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_z_clear() {
    // arrange - code
    // ASL.L #$02,D7
    let code = [0xE5, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x01010101);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$02,D7"),
            vec![0xE587]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x04040404);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_v_set() {
    // arrange - code
    // ASL.L #$03,D7
    let code = [0xE7, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x40000000);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$03,D7"),
            vec![0xE787]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_immediate_v_clear() {
    // arrange - code
    // ASL.L #$03,D7
    let code = [0xE7, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x08080808);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("#$03,D7"),
            vec![0xE787]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x40404040);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_cx_set() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0c0c0c0c);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x01818181);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_cx_clear() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x78787878);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0f0f0f0f);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_n_set() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0xc0c0c0c0);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0xf8181818);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_n_clear() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x70707070);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x0e0e0e0e);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_z_set() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000007);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x00000000);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_z_clear() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x08080808);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x01010101);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_immediate_v_clear() {
    // arrange - code
    // ASR.L #$03,D7
    let code = [0xE6, 0x87].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x18181818);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("#$03,D7"),
            vec![0xE687]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000080, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x03030303);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_register_cx_shift_0_c_clear_x_unaffected_still_set() {
    // arrange - code
    // ASL.B D0,D5
    let code = [0xE1, 0x25].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("D0,D5"),
            vec![0xE125]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_register_cx_shift_0_c_clear_x_unaffected_still_clear() {
    // arrange - code
    // ASL.B D0,D5
    let code = [0xE1, 0x25].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("D0,D5"),
            vec![0xE125]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_register_cx_shift_0_c_clear_x_unaffected_still_set() {
    // arrange - code
    // ASR.B D1,D4
    let code = [0xE2, 0x24].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x00000014, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("D1,D4"),
            vec![0xE224]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x00000014, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_register_cx_shift_0_c_clear_x_unaffected_still_clear() {
    // arrange - code
    // ASR.B D1,D4
    let code = [0xE2, 0x24].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x00000014, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("D1,D4"),
            vec![0xE224]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x00000014, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_register_cx_shift_0_c_clear_x_unaffected_still_set() {
    // arrange - code
    // ASL.W D0,D5
    let code = [0xE1, 0x65].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x0000d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("D0,D5"),
            vec![0xE165]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x0000d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_register_cx_shift_0_c_clear_x_unaffected_still_clear() {
    // arrange - code
    // ASL.W D0,D5
    let code = [0xE1, 0x65].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x0000d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("D0,D5"),
            vec![0xE165]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x0000d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_register_cx_shift_0_c_clear_x_unaffected_still_set() {
    // arrange - code
    // ASR.W D1,D4
    let code = [0xE2, 0x64].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x000014d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("D1,D4"),
            vec![0xE264]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x000014d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_register_cx_shift_0_c_clear_x_unaffected_still_clear() {
    // arrange - code
    // ASR.W D1,D4
    let code = [0xE2, 0x64].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x000014d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("D1,D4"),
            vec![0xE264]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x000014d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_register_cx_shift_0_c_clear_x_unaffected_still_set() {
    // arrange - code
    // ASL.L D0,D5
    let code = [0xE1, 0xA5].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0xd5d5d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("D0,D5"),
            vec![0xE1A5]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0xd5d5d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_register_cx_shift_0_c_clear_x_unaffected_still_clear() {
    // arrange - code
    // ASL.L D0,D5
    let code = [0xE1, 0xA5].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0xd5d5d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("D0,D5"),
            vec![0xE1A5]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffffc0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0xd5d5d5d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_register_cx_shift_0_c_clear_x_unaffected_still_set() {
    // arrange - code
    // ASR.L D1,D4
    let code = [0xE2, 0xA4].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x14d4d4d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("D1,D4"),
            vec![0xE2A4]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x14d4d4d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_register_cx_shift_0_c_clear_x_unaffected_still_clear() {
    // arrange - code
    // ASR.L D1,D4
    let code = [0xE2, 0xA4].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x14d4d4d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("D1,D4"),
            vec![0xE2A4]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffffc0, 0x000000d2, 0x000000d3, 0x14d4d4d4, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_b_register_by_register_big_shift() {
    // arrange - code
    // ASL.B D0,D5
    let code = [0xE1, 0x25].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffff3f, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000ff, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.B"),
            String::from("D0,D5"),
            vec![0xE125]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffff3f, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x00000000, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_b_register_by_register_big_shift() {
    // arrange - code
    // ASR.B D1,D4
    let code = [0xE2, 0x24].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x00000080, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.B"),
            String::from("D1,D4"),
            vec![0xE224]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x000000ff, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_register_by_register_big_shift() {
    // arrange - code
    // ASL.W D0,D5
    let code = [0xE1, 0x65].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffff3f, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x0000ffff, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("D0,D5"),
            vec![0xE165]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffff3f, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x00000000, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_w_register_by_register_big_shift() {
    // arrange - code
    // ASR.W D1,D4
    let code = [0xE2, 0x64].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x00008000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("D1,D4"),
            vec![0xE264]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x0000ffff, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_l_register_by_register_big_shift() {
    // arrange - code
    // ASL.L D0,D5
    let code = [0xE1, 0xA5].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0xffffff3f, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0xffffffff, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.L"),
            String::from("D0,D5"),
            vec![0xE1A5]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0xffffff3f, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x00000000, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asr_l_register_by_register_big_shift() {
    // arrange - code
    // ASR.L D1,D4
    let code = [0xE2, 0xA4].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    // -nothing-

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.L"),
            String::from("D1,D4"),
            vec![0xE2A4]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0xffffffff, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    // -nothing-
}

#[test]
fn asl_w_memory_by_1_areg_indirect_with_predecrement() {
    // arrange - code
    // ASL.W -(A0)
    let code = [0xE1, 0xE0].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    let arrange_mem_bytes_00050110 = [0x10, 0x10].to_vec();
    let arrange_mem_00050110 = RamMemory::from_bytes(0x00050110, arrange_mem_bytes_00050110);

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    mem.add_range(Rc::new(RefCell::new(arrange_mem_00050110)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x00050112, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASL.W"),
            String::from("-(A0)"),
            vec![0xE1E0]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x00050110, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    assert_eq!(0x20, modermodem.mem.get_byte_no_log(0x00050110));
    assert_eq!(0x20, modermodem.mem.get_byte_no_log(0x00050111));
}

#[test]
fn asl_w_memory_by_1_areg_indirect_with_displacement() {
    // arrange - code
    // ASL.W ($0040,A0)
    let code = [0xE1, 0xE8, 0x00, 0x40].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    let arrange_mem_bytes_00050110 = [0x80, 0x01].to_vec();
    let arrange_mem_00050110 = RamMemory::from_bytes(0x00050110, arrange_mem_bytes_00050110);

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    mem.add_range(Rc::new(RefCell::new(arrange_mem_00050110)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000500d0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040004,
            String::from("ASL.W"),
            String::from("($0040,A0)"),
            vec![0xE1E8,0x0040]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000500d0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    assert_eq!(0x00, modermodem.mem.get_byte_no_log(0x00050110));
    assert_eq!(0x02, modermodem.mem.get_byte_no_log(0x00050111));
}

#[test]
fn asr_w_memory_by_1_areg_indirect_with_postincrement() {
    // arrange - code
    // ASR.W (A6)+
    let code = [0xE0, 0xDE].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    let arrange_mem_bytes_00050110 = [0x10, 0x10].to_vec();
    let arrange_mem_00050110 = RamMemory::from_bytes(0x00050110, arrange_mem_bytes_00050110);

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    mem.add_range(Rc::new(RefCell::new(arrange_mem_00050110)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x00050112, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x00050110, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_OVERFLOW
       | STATUS_REGISTER_MASK_CARRY
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("(A6)+"),
            vec![0xE0DE]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x00050112, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x00050112, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       0x0000
    );

    // assert - mem
    assert_eq!(0x08, modermodem.mem.get_byte_no_log(0x00050110));
    assert_eq!(0x08, modermodem.mem.get_byte_no_log(0x00050111));
}

#[test]
fn asr_w_memory_by_1_areg_indirect() {
    // arrange - code
    // ASR.W (A5)
    let code = [0xE0, 0xD5].to_vec();
    let code_memory = RamMemory::from_bytes(0x00040000, code);

    // arrange - mem
    let arrange_mem_bytes_00050110 = [0x00, 0x01].to_vec();
    let arrange_mem_00050110 = RamMemory::from_bytes(0x00050110, arrange_mem_bytes_00050110);

    // arrange - common
    let mut mem = Mem::new(None, None);
    let vectors = RamMemory::from_range(0x00000000, 0x000003ff);
    let cia_memory = CiaMemory::new();
    mem.add_range(Rc::new(RefCell::new(code_memory)));
    mem.add_range(Rc::new(RefCell::new(vectors)));
    mem.add_range(Rc::new(RefCell::new(cia_memory)));
    mem.add_range(Rc::new(RefCell::new(arrange_mem_00050110)));
    let cpu = Cpu::new(CpuSpeed::NTSC_7_159090_MHz, 0x00000000, 00040000);
    let mut modermodem = Modermodem::bare(cpu, mem);

    // arrange - regs
    modermodem.cpu.register.set_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.set_all_a_reg_long_no_log(0x000500d0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x00050110, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_pc = ProgramCounter::from_address(0x00040000);
    modermodem.cpu.register.reg_sr.set_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_NEGATIVE
       | STATUS_REGISTER_MASK_OVERFLOW
    );

    // act/assert - disassembly
    let get_disassembly_result = modermodem.get_next_disassembly_no_log();
    assert_eq!(
        GetDisassemblyResult::from_address_and_address_next(
            0x00040000,
            0x00040002,
            String::from("ASR.W"),
            String::from("(A5)"),
            vec![0xE0D5]
            ),
            get_disassembly_result
        );

    // act
    modermodem.step();

    // assert - regs
    modermodem.cpu.register.assert_all_d_reg_long_no_log(0x00000000, 0xffffff3f, 0x000000d2, 0x000000d3, 0x80000000, 0x000000d5, 0x000000d6, 0x000000d7);
    modermodem.cpu.register.assert_all_a_reg_long_no_log(0x000500d0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x00050110, 0x000000a6, 0x000000a7);
    modermodem.cpu.register.reg_sr.assert_sr_reg_flags_abcde(
       STATUS_REGISTER_MASK_EXTEND
       | STATUS_REGISTER_MASK_ZERO
       | STATUS_REGISTER_MASK_CARRY
    );

    // assert - mem
    assert_eq!(0x00, modermodem.mem.get_byte_no_log(0x00050110));
    assert_eq!(0x00, modermodem.mem.get_byte_no_log(0x00050111));
}
